<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://fabmazz.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://fabmazz.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-02-25T16:57:50+00:00</updated><id>https://fabmazz.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal website of Fabio Mazza </subtitle><entry><title type="html">Making isochrones with OpenStreetMap data and GTFS</title><link href="https://fabmazz.github.io/blog/2024/gtfs-isochrones/" rel="alternate" type="text/html" title="Making isochrones with OpenStreetMap data and GTFS"/><published>2024-02-23T21:01:00+00:00</published><updated>2024-02-23T21:01:00+00:00</updated><id>https://fabmazz.github.io/blog/2024/gtfs-isochrones</id><content type="html" xml:base="https://fabmazz.github.io/blog/2024/gtfs-isochrones/"><![CDATA[<p>Isochrone maps (or simply, isochrones) are a way of of showing all the locations that are reachable, starting from a certain point, within a certain time. They’re often made to show how far one can travel by car or by bike, and I first encountered them when reading about public transport in <a href="https://www.opentripplanner.org/" target="blank">OpenTripPlanner</a>. This is a wonderful open source software that, given the appropriate data, can calculate the best way of moving from one place to another with public transport, much like Google Maps does. I tried it out with the data for Turin, Piedmont, and it’s really fast and easy to setup (after figuring out which data to download, that has to be from OpenStreetMap for the road network and GTFS for the public transport, but more on that later).</p> <p>After digging around, I discovered that OpenTripPlanner can also make isochrones, via an API that is a bit hidden in the documentation. My guess is that it was actively used before, but since the project has recently undergone some changes, it’s now not that important any more. After downloading the GTFS data of Gruppo Torinese Trasporti from <a href="http://aperto.comune.torino.it" target="_blank">AperTO</a>, I tried computing an isochrone starting from the station of Torino Porta Nuova, on the 16th January 2024 at 20:40, and I obtained the following result:</p> <figure class="text-center"> <a href="/assets/img/gtfs_isochrones/isochrone_otp.jpg" target="_blank"> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/gtfs_isochrones/isochrone_otp-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/gtfs_isochrones/isochrone_otp-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/gtfs_isochrones/isochrone_otp-1400.webp"/> <img src="/assets/img/gtfs_isochrones/isochrone_otp.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Isochrone from OpenTripPlanner" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </a> </figure> <p>The layers here correspond to having travel times lower than 10, 20, 30, 40, 50 and 60 minutes from the initial point, with lower times with darker color. While this looks okay, I was soon made aware that, in fact, it was a little wrong, as going from Porta Nuova to Fermi (near Collegno) would take about 25 minutes with the underground, but on the map was shown between 30 and 40 minutes. Of course, my interest was immediately piqued, and I had to compute an isochrone map by myself.</p> <h2 id="downloading-the-data">Downloading the data</h2> <p>In order to compute the isochrones more accurately, I had first to download the OpenStreetMap (OSM) network, but the problem is that it is huge and very detailed, and I would have had to manually remove all useless information.</p> <p>Luckily, I found the <a href="https://osmnx.readthedocs.io/en/stable/index.html" target="_blank">OSMnx</a> Python library, that made it possible to download only the relevant part of the OSM data, which is the <i>walk</i> network. It is still a very large network (~190k nodes), and this called for some simplification to be done. At the end, I decided not to use the tools provided by OSMnx, as they were removing too many nodes (and replacing links with geolocated paths, which would have complicated the calculation). In fact, the main reason is that, while the downloaded network was a directed weighted graph, but fully symmetric (as it should be when walking), after the simplification methods were applied, some nodes were assigned two different paths between them, which were not even symmetric!</p> <p>Instead of doing this complex kind of optimization, I just decided to remove the nodes which were inside a chain (so, having degree 2) whose neighbors had a total distance of less than 50 meters (so, summing the weights of the links to that node). At the end, I managed to remove about 20k nodes, going down to a size of ~170k total nodes.</p> <h2 id="writing-the-algorithm">Writing the algorithm</h2> <p>For this project, I was really tempted to use the Julia programming language again. Since I wasn’t able to read the full OSM network from the GraphML file in which I saved it from python, I had to simply save the nodes information and the edges list separately in Parquet data frames. Everything was going well: once the OSM graph was reconstructed, the stops had to be added to the graph (to better compute the distances from one stop to the other). Here is when I encountered a problem: I wanted to find the points closest to the stops, and in order to it efficiently I decided to use a <a href="https://en.wikipedia.org/wiki/K-d_tree" target="_blank">k-d tree</a>. Unfortunately, the Julia implementation of k-d tree got stuck when I fed it the ~170k points from OSM, so… I had to use Python (the scipy version worked great!).</p> <p>So, at the end I had the following ingredients:</p> <ul> <li>a graph of all the points in the map, plus the stops, to compute the distances in meters from one point of the graph to all the others</li> <li>a kd-tree of all the OSM points (to find the closest one to the starting point I picked)</li> <li>the GTFS data, which was describing all the public transport trips</li> </ul> <p>I will now discuss each point separately, starting from the one I’ve never described until now.</p> <h4 id="extracting-the-trips-information-from-gtfs">Extracting the trips information from GTFS</h4> <p>The <a href="https://en.wikipedia.org/wiki/GTFS" target="_blank"><del>Google</del> General Transit Format Specification</a> is a very flexible standard to describe public service options. It’s now used worldwide, and is tightly integrated into Google Maps (of course!). I was able to find the data for buses and metro of Torino, but not the one for local trains (operated by Trenitalia). In fact, if any individual working for Trenitalia is reading this now, please find a way to distribute the transit data!! It’s totally unfair that Google has access to it, but it’s impossible to find for everybody else.</p> <p>On the practical side, the most important table from GTFS is the <code class="language-plaintext highlighter-rouge">stoptimes</code>, which links trips and stops with the time of arrival/departure (for GTT, they are the same). However, in order to distinguish which trips are actually made on a particular day, it’s necessary to use the <code class="language-plaintext highlighter-rouge">calendar</code> and <code class="language-plaintext highlighter-rouge">calendar_dates</code>, that show the service days. If it’s important to know <em>which</em> public transport line is taken (like giving directions), then of course the <code class="language-plaintext highlighter-rouge">routes</code> table is fundamental. The <code class="language-plaintext highlighter-rouge">trips</code> table is needed to link the service days with the trips.</p> <p>Once a day is selected, all of the information from GTFS can be contained in a single table/dataframe, which is a selection of the <code class="language-plaintext highlighter-rouge">stoptimes</code> with only the active trips of the day.</p> <h4 id="the-street-graph-and-the-k-d-tree">The street graph and the k-d tree</h4> <p>The street graph is central to the algorithm, as each time a public transport user gets off a bus, he/she needs to know how distant all the places around him/her are. The important idea here is that this is needed <em>at each stop</em> a person can get off, thus, the graph distances can be precomputed only for these nodes (there still are ~4500 stops, but try saving a 170k * 170k matrix!). To compute the shortest distance, I’ve used the Dijkstra algorithm, since the distances in the edges can only be positive.</p> <p>As mentioned above, the k-d tree is needed only to find the closest node of the graph to the starting point, and this is the only time I’ll have to run the shortest path for the whole time. Nice!</p> <h3 id="putting-it-all-together">Putting it all together</h3> <p>With the precomputed distance matrix, the filtered GTFS stop times, the network and the k-d tree it’s now possible to find the time taken to reach all the points in the graph using public transport (with a few extra hash tables for fast lookup of stop nodes ids). To avoid continuously all stops, it’s possible to track their total reaching time in a priority queue.</p> <p>The idea is to get the stop with the lowest arrival time (which hasn’t been checked yet), find the trips that start from that stop, then find all the stops that can be reached by the each trip, and check if the time of arrival is lower than the one previously saved. If it is, put the arrival stop back in the queue with the new arrival time, and then update the time taken to reach all other points from that stop (only if it’s lower, of course).</p> <p>By repeating the steps in the above paragraph until there are no more stops to check, we can be sure that there are no trips that take a lower time to get to any single point. At the end, we get a vector representing the time taken to reach each point in the (extended) street graph.</p> <h2 id="visualizing-the-result">Visualizing the result</h2> <p>In order to show the isochrone map, I tried using the geopandas library at first, to group together all the points that can be reached with a set time. This led to the problem of defining the outline of the reachable area, which turns out is intrinsically linked to the <a href="https://gis.stackexchange.com/questions/1200/what-are-definition-algorithms-and-practical-solutions-for-concave-hull" target="_blank">concave hull problem</a>. I found a fast and reasonably good library for this calculation, but this was at times imprecise.</p> <p>After some online digging, I found that the <code class="language-plaintext highlighter-rouge">matplotlib</code> library had all the tools I needed. By re-elaborating on <a href="https://matplotlib.org/stable/gallery/images_contours_and_fields/irregulardatagrid.html" target="_blank">this example</a>, I was able to get very good-looking isochrones, like the following (still starting from Porta Nuova station):</p> <figure class="text-center"> <a href="/assets/img/gtfs_isochrones/isochrone_pn_example.png" target="_blank"> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/gtfs_isochrones/isochrone_pn_example-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/gtfs_isochrones/isochrone_pn_example-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/gtfs_isochrones/isochrone_pn_example-1400.webp"/> <img src="/assets/img/gtfs_isochrones/isochrone_pn_example.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Isochrone calculated from Porta Nuova" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </a> </figure> <p>Looking at this picture, it’s possible to conclude that the previous isochrone map made by OpenTripPlanner wasn’t entirely wrong: in fact, the area around the “Fermi” underground station is under 30 minutes, but it’s also very small, which could explain why the (probably more approximated) method used by OpenTripPlanner missed it.</p> <p>I have run the algorithm on a randomly-chosen day (20th January), with starting time varying from 5 am to 1 am in the following day (which is the same service day for GTFS), and have published all the images obtained, along with the code, in a <a href="https://github.com/fabmazz/gtfsisochrones" target="_blank">Github repo</a>.</p> <h3 id="extra-number-of-trips-taken">Extra: number of trips taken</h3> <p>With a simple (but not entirely trivial) modification, I was able to track the number of trips that are needed, at least, to reach a certain point. One trial result is shown below:</p> <figure class="text-center"> <a href="/assets/img/gtfs_isochrones/lines.jpg" target="_blank"> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/gtfs_isochrones/lines-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/gtfs_isochrones/lines-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/gtfs_isochrones/lines-1400.webp"/> <img src="/assets/img/gtfs_isochrones/lines.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Number of trips taken" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </a><figcaption class="caption">Number of different trips taken to reach each point, lighter colors indicate less. Possible values are either 0, 1, 2, 3 or 4</figcaption> </figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Isochrone maps (or simply, isochrones) are a way of of showing all the locations that are reachable, starting from a certain point, within a certain time. They’re often made to show how far one can travel by car or by bike, and I first encountered them when reading about public transport in OpenTripPlanner. This is a wonderful open source software that, given the appropriate data, can calculate the best way of moving from one place to another with public transport, much like Google Maps does. I tried it out with the data for Turin, Piedmont, and it’s really fast and easy to setup (after figuring out which data to download, that has to be from OpenStreetMap for the road network and GTFS for the public transport, but more on that later).]]></summary></entry><entry><title type="html">Analysing the real-time position public transport data in Turin</title><link href="https://fabmazz.github.io/blog/2024/torino-bus/" rel="alternate" type="text/html" title="Analysing the real-time position public transport data in Turin"/><published>2024-02-10T21:01:00+00:00</published><updated>2024-02-10T21:01:00+00:00</updated><id>https://fabmazz.github.io/blog/2024/torino-bus</id><content type="html" xml:base="https://fabmazz.github.io/blog/2024/torino-bus/"><![CDATA[<p>I have recently begun analysing a dataset of real-time positions of the vehicles of the GTT public transport operator in Turin, Italy. The dataset contained information of the position of each vehicle at a particular time, and the line and the number of the vehicle along a trip identifier.</p> <p>The positions have been collected over the first two weeks of December 2023, and the total amount is about 21 million, from all public transport lines. You can see how many positions are collected at each minute in the figure below:</p> <figure> <a href="/assets/img/positions/counts_pos.png" target="_blank"> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/positions/counts_pos-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/positions/counts_pos-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/positions/counts_pos-1400.webp"/> <img src="/assets/img/positions/counts_pos.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Count of positions updates" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </a> </figure> <p>It’s curious to note that on the weekend the number of positions collected is markedly lower (the 3rd of December was a Sunday, and the 8th December is a national holiday in Italy).</p> <p>Because of the very high number of positions, and of my ever-present interest in new programming languages, I decided to use <a href="https://www.julialang.org" target="blank">Julia</a> for this analysis, as it is very intuitive and fast.</p> <h2 id="cleaning-up-the-data">Cleaning up the data</h2> <p>The dataset had to be removed of all spurious data points which could not be possibly explained. In fact, there are several points that were very far from Italy, or from Turin in general. Some trams GPS, were, for example, continuously jumping from Turin to Genoa for no apparent reason: this made for an average speed of more than 1000 km/h!</p> <figure> <a href="/assets/img/positions/jumping_line.jpg" target="_blank"> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/positions/jumping_line-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/positions/jumping_line-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/positions/jumping_line-1400.webp"/> <img src="/assets/img/positions/jumping_line.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Vehicle jumping around" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </a> </figure> <div class="caption"> A trace of a vehicle jumping continuously from Turin to another city </div> <p>Therefore, I set to remove all positions with a distance from the center of Turin higher than 17.5 km. I also decided to discard any data points without a trip identifier, for reasons which will become clearer later.</p> <p>Then, I separated the data by line, vehicle number and trip id, thus creating a trace of each vehicle on each trip. After cutting each trace when it jumped more than 500 m and by more than a minute and half, I had a series of traces for the trips, and I proceeded to analyse each line individually.</p> <h2 id="line-analysis">Line analysis</h2> <p>At this point, I had another problem: sometimes the data of the trace is not cut when the vehicle leaves service and goes to the depot. This is very evident in line 10, for example, whose trams make all the way from the center to the north depot of Venaria at night time.</p> <p>Therefore, I used the track information of each line, which is a polyline showing the general path of a line, and the list of stops the line makes. Initially, I split the polyLine into regular sections of 500 m: this was done by dividing the polyline in many small segments, then finding the one which passed the threshold each time. Obviously, there is not a perfect correspondance between the points where each section begins and the positions recorded for a vehicle. Thus, I inserted a new position in the vehicle trace for each section: since the trace is actually a collection of segments, in geometrical terms, it’s only necessary to split the segment at a new point closest to the section point. For the time of the new “recorded” position, working under the assumption of simple linear motion, I put the mean averaged by the distance between the two ends of the segment.</p> <p>Below you can see an example on the map, with the line trajectory or polyline in grey, the section points in light blue, and the trace in blu with each of its point highlighted. The red crosses represent the new point that are inserted in the vehicle trace:</p> <div class="mt-0 mt-md-0 mx-auto float-end" style="max-width:350px"> <figure> <a href="/assets/img/positions/line_section.jpg" target="_blank"> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/positions/line_section-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/positions/line_section-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/positions/line_section-1400.webp"/> <img src="/assets/img/positions/line_section.jpg" class="float-end img-fluid rounded z-depth-1" width="auto" height="auto" title="Line sections and trace" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </a> </figure> </div> <p>The polyline was also useful to the determine when the bus was leaving service and going to the depot: by keeping the vehicle positions within a small threshold of the polyline points (about 30 meters), the trace of the vehicle was well defined. The division is section made it possible to also distinguish when the vehicle was actually running in the direction opposite to that of the trip (from south to north in the previous example).</p> <p>After this part was done, I was able to compute the average per section on each trip. This was done by computing the total distance travelled by each vehicle in each section, and the time spent in each section, and then diving them. What I’ve obtained now is a new coarse-grained dataset, for which there are also timestamps of each section/trip/vehicle tuple.</p> <p>From this new dataset, I’ve obtained a few different results, averaging the speed on either just the section or the hour of the day. The two figures below show the average speed on the map, and for each section at each day.</p> <div class="mt-0 mt-md-0 mx-auto float-end" style="max-width:500px"> <figure> <a href="/assets/img/positions/avg_speed_map_09_1.jpg" target="_blank"> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/positions/avg_speed_map_09_1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/positions/avg_speed_map_09_1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/positions/avg_speed_map_09_1-1400.webp"/> <img src="/assets/img/positions/avg_speed_map_09_1.jpg" class="float-end img-fluid rounded z-depth-1" width="auto" height="auto" title="Average speed for section" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </a> </figure> </div> <div class="mt-0 mt-md-0 mx-auto float-end"> <figure> <a href="/assets/img/positions/avg_speed_matr_09_1.jpg" target="_blank"> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/positions/avg_speed_matr_09_1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/positions/avg_speed_matr_09_1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/positions/avg_speed_matr_09_1-1400.webp"/> <img src="/assets/img/positions/avg_speed_matr_09_1.jpg" class="float-end img-fluid rounded z-depth-1" width="auto" height="auto" title="Average speed for section" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </a> </figure> </div> <p>From these two figures, it can be seen that the speed varies a lot depending on the part of the trajectory, and it’s unclear on which factors it depends. Since the 9 is a tramway line, it might be possible that the high speed of section 19 is due to the state of the tracks there (it’s completely separated by other traffic). However, the presence of close stops might also explain the low speed of other sections.</p> <h2 id="future-outlooks">Future outlooks</h2> <p>So far, I’ve only done this analysis on line 9, and I think it’s really cool to see the real (although, averaged) speed of a public transport line. I think that the ability to look at different times during the day is also important, and one interesting question that remains to be answered is whether the physical separation is helpful in keeping an higher average speed in the public transport. The answer should be “yes, of course”, but I’d be quite cool to see it from the data.</p> <p>Moreover, it would be interesting to see if there is a difference in average speed between the hours of high peak traffic, and the hours of low traffic. These questions could be answered also by extending the analysis into several weeks of data.</p> <p>P.S. I’ve published the code for the analysis on Github, available <a href="https://github.com/fabmazz/PositionsParsing" target="_blank">here</a>.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[I have recently begun analysing a dataset of real-time positions of the vehicles of the GTT public transport operator in Turin, Italy. The dataset contained information of the position of each vehicle at a particular time, and the line and the number of the vehicle along a trip identifier.]]></summary></entry></feed>